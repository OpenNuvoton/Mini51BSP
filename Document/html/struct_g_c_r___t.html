<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mini51 BSP: GCR_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="M0Banner_v2.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mini51 BSP
   &#160;<span id="projectnumber">V3.02.001</span>
   </div>
   <div id="projectbrief">The Board Support Package for Mini51 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">GCR_T Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:af8a567a29d2750af51eb932b7664baa3"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#af8a567a29d2750af51eb932b7664baa3">PDID</a></td></tr>
<tr class="separator:af8a567a29d2750af51eb932b7664baa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe5bb4fd7cc545439b3ea01246d1524"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#aafe5bb4fd7cc545439b3ea01246d1524">RSTSRC</a></td></tr>
<tr class="separator:aafe5bb4fd7cc545439b3ea01246d1524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3e3d053549ccc13eb3f69a4dab6a87"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#a1a3e3d053549ccc13eb3f69a4dab6a87">IPRSTC1</a></td></tr>
<tr class="separator:a1a3e3d053549ccc13eb3f69a4dab6a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45998c8dd85ae954f05133beaa5e9616"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#a45998c8dd85ae954f05133beaa5e9616">IPRSTC2</a></td></tr>
<tr class="separator:a45998c8dd85ae954f05133beaa5e9616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6e038485d188d96689a2c780a47982"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#a0f6e038485d188d96689a2c780a47982">BODCTL</a></td></tr>
<tr class="separator:a0f6e038485d188d96689a2c780a47982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1703db134b6af85b089fb24527f9ae9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#af1703db134b6af85b089fb24527f9ae9">P0_MFP</a></td></tr>
<tr class="separator:af1703db134b6af85b089fb24527f9ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79ddc89f5e3b8253388260889dc6a83"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#ab79ddc89f5e3b8253388260889dc6a83">P1_MFP</a></td></tr>
<tr class="separator:ab79ddc89f5e3b8253388260889dc6a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15d3c4cdaab63d4e0a501303a005d0e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#ab15d3c4cdaab63d4e0a501303a005d0e">P2_MFP</a></td></tr>
<tr class="separator:ab15d3c4cdaab63d4e0a501303a005d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e963f7ef36cb80a29e07f0c896da2d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#a02e963f7ef36cb80a29e07f0c896da2d">P3_MFP</a></td></tr>
<tr class="separator:a02e963f7ef36cb80a29e07f0c896da2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad086af8759866118e50e71756e605f16"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#ad086af8759866118e50e71756e605f16">P4_MFP</a></td></tr>
<tr class="separator:ad086af8759866118e50e71756e605f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3e0d273e94aada01adfad33c9a71b9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#a3e3e0d273e94aada01adfad33c9a71b9">P5_MFP</a></td></tr>
<tr class="separator:a3e3e0d273e94aada01adfad33c9a71b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f61a8a5f0021ff7d1df90012cfc7b8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#a87f61a8a5f0021ff7d1df90012cfc7b8">IRCTRIMCTL</a></td></tr>
<tr class="separator:a87f61a8a5f0021ff7d1df90012cfc7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa506a80cdcd8402609161d711bfcde56"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#aa506a80cdcd8402609161d711bfcde56">IRCTRIMIER</a></td></tr>
<tr class="separator:aa506a80cdcd8402609161d711bfcde56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4f4419d8713b07c3ede187da4c274a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#acc4f4419d8713b07c3ede187da4c274a">IRCTRIMISR</a></td></tr>
<tr class="separator:acc4f4419d8713b07c3ede187da4c274a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55058438f0f5bd20b75de051e8bbef49"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_c_r___t.html#a55058438f0f5bd20b75de051e8bbef49">RegLockAddr</a></td></tr>
<tr class="separator:a55058438f0f5bd20b75de051e8bbef49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup GCR System Global Control Registers(GCR)
Memory Mapped Structure for GCR Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l01954">1954</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a0f6e038485d188d96689a2c780a47982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6e038485d188d96689a2c780a47982">&#9670;&nbsp;</a></span>BODCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::BODCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">BODCTL
</font><br><p> <font size="2">
Offset: 0x18  Brown-out Detector Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>BOD_VL_EXT</td><td><div style="word-wrap: break-word;"><b>Brown-out Detector Selection Extension (Initiated & Write-protected Bit)
</b><br>
The default value is set by flash controller user configuration CBOVEXT bit (config0 [23]).
<br>
If config0 bit[23] is set to 1, default value of BOD_VL_EXT is 0.
<br>
If config0 bit[23] is set to 0, default value of BOD_VL_EXT is 1.
<br>
0 = Brown-out detector threshold voltage is selected by the table defined in BOD_VL.
<br>
1 = Brown-out detector threshold voltage is selected by the table defined below.
<br>
11 = 4.4V
<br>
10 = 3.7V
<br>
01 = 2.7V
<br>
00 = 2.2V
<br>
</div></td></tr><tr><td>
[2:1]</td><td>BOD_VL</td><td><div style="word-wrap: break-word;"><b>Brown-out Detector Threshold Voltage Selection (Initiated & Write-protected Bit)
</b><br>
The default value is set by flash controller user configuration CBOV bit (config0 [22:21]).
<br>
BOD_VL[1]
<br>
BOD_VL[0]
<br>
Brown-out   voltage
<br>
11 = Disable
<br>
10 = 3.7V
<br>
01 = 2.7V
<br>
00 = Reserved
<br>
</div></td></tr><tr><td>
[3]</td><td>BOD_RSTEN</td><td><div style="word-wrap: break-word;"><b>Brown-out Reset Enable Control (Initiated And Write-protected Bit)
</b><br>
0 = Brown-out "INTERRUPT" function Enabled; when the Brown-out Detector function is enable and the detected voltage is lower than the threshold, then assert a signal to interrupt the Cortex-M0 CPU.
<br>
1 = Brown-out "RESET" function Enabled; when the Brown-out Detector function is enable and the detected voltage is lower than the threshold then assert a signal to reset the chip.
<br>
The default value is set by flash controller user configuration register config0 bit[20].
<br>
When the BOD_EN is enabled and the interrupt is asserted, the interrupt will be kept till the BOD_EN is set to 0.
<br>
The interrupt for CPU can be blocked by disabling the NVIC in CPU for BOD interrupt or disable the interrupt source by disabling the BOD_EN and then re-enabling the BOD_EN function if the BOD function is required.
<br>
</div></td></tr><tr><td>
[4]</td><td>BOD_INTF</td><td><div style="word-wrap: break-word;"><b>Brown-out Detector Interrupt Flag
</b><br>
0 = Brown-out Detector does not detect any voltage dropped at AVDD down through or up through the voltage of BOD_VL setting.
<br>
1 = When Brown-out Detector detects the AVDD is dropped through the voltage of BOD_VL setting or the AVDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and the Brown-out interrupt is requested if Brown-out interrupt is enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>BOD_LPM</td><td><div style="word-wrap: break-word;"><b>Brown-out Detector Low Power Mode (Write Protect)
</b><br>
0 = BOD operate in normal mode (default).
<br>
1 = Enable the BOD low power mode.
<br>
The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1uA but slow the BOD response.
<br>
</div></td></tr><tr><td>
[6]</td><td>BOD_OUT</td><td><div style="word-wrap: break-word;"><b>Brown-out Detector Output State
</b><br>
0 = Brown-out Detector status output is 0, the detected voltage is higher than BOD_VL setting.
<br>
1 = Brown-out Detector status output is 1, the detected voltage is lower than BOD_VL setting.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02687">2687</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a1a3e3d053549ccc13eb3f69a4dab6a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3e3d053549ccc13eb3f69a4dab6a87">&#9670;&nbsp;</a></span>IPRSTC1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::IPRSTC1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IPRSTC1
</font><br><p> <font size="2">
Offset: 0x08  Peripheral Reset Control Resister 1
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CHIP_RST</td><td><div style="word-wrap: break-word;"><b>CHIP One-shot Reset (Write Protect)
</b><br>
Setting this bit will reset the CHIP, including CPU kernel and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
<br>
The CHIP_RST is the same as the POR reset, and all the chip module is reset and the chip settings from flash are also reloaded.
<br>
0 = Chip normal operation.
<br>
1 = CHIP one-shot reset.
<br>
Note: This bit is the protected bit, and programming it needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
<br>
Refer to the register REGWRPROT at address GCR_BA + 0x100.
<br>
</div></td></tr><tr><td>
[1]</td><td>CPU_RST</td><td><div style="word-wrap: break-word;"><b>CPU Kernel Reset
</b><br>
Setting this bit will reset the CPU kernel, and this bit will automatically return to 0 after the 2 clock cycles.
<br>
0 = CPU normal operation.
<br>
1 = Reset CPU Kernel.
<br>
Note: This bit is the protected bit, and programming it needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
<br>
Refer to the register REGWRPROT at address GCR_BA + 0x100.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02682">2682</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a45998c8dd85ae954f05133beaa5e9616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45998c8dd85ae954f05133beaa5e9616">&#9670;&nbsp;</a></span>IPRSTC2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::IPRSTC2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IPRSTC2
</font><br><p> <font size="2">
Offset: 0x0C  Peripheral Reset Control Resister 2
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>GPIO_RST</td><td><div style="word-wrap: break-word;"><b>GPIO (P0~P5) Controller Reset
</b><br>
0 = GPIO module normal operation.
<br>
1 = GPIO module reset.
<br>
</div></td></tr><tr><td>
[2]</td><td>TMR0_RST</td><td><div style="word-wrap: break-word;"><b>Timer0 Controller Reset
</b><br>
0 = Timer0 module normal operation.
<br>
1 = Timer0 module reset.
<br>
</div></td></tr><tr><td>
[3]</td><td>TMR1_RST</td><td><div style="word-wrap: break-word;"><b>Timer1 Controller Reset
</b><br>
0 = Timer1 module normal operation.
<br>
1 = Timer1 module reset.
<br>
</div></td></tr><tr><td>
[8]</td><td>I2C_RST</td><td><div style="word-wrap: break-word;"><b>I2C Controller Reset
</b><br>
0 = I2C module normal operation.
<br>
1 = I2C module reset.
<br>
</div></td></tr><tr><td>
[12]</td><td>SPI_RST</td><td><div style="word-wrap: break-word;"><b>SPI Controller Reset
</b><br>
0 = SPI module normal operation.
<br>
1 = SPI module reset.
<br>
</div></td></tr><tr><td>
[16]</td><td>UART_RST</td><td><div style="word-wrap: break-word;"><b>UART Controller Reset
</b><br>
0 = UART module normal operation.
<br>
1 = UART module reset.
<br>
</div></td></tr><tr><td>
[20]</td><td>PWM_RST</td><td><div style="word-wrap: break-word;"><b>PWM Controller Reset
</b><br>
0 = PWM module normal operation.
<br>
1 = PWM module reset.
<br>
</div></td></tr><tr><td>
[22]</td><td>ACMP_RST</td><td><div style="word-wrap: break-word;"><b>ACMP Controller Reset
</b><br>
0 = ACMP module normal operation.
<br>
1 = ACMP module reset.
<br>
</div></td></tr><tr><td>
[28]</td><td>ADC_RST</td><td><div style="word-wrap: break-word;"><b>ADC Controller Reset
</b><br>
0 = ADC module normal operation.
<br>
1 = ADC module reset.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02683">2683</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a87f61a8a5f0021ff7d1df90012cfc7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f61a8a5f0021ff7d1df90012cfc7b8">&#9670;&nbsp;</a></span>IRCTRIMCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::IRCTRIMCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IRCTRIMCTL
</font><br><p> <font size="2">
Offset: 0x80  HIRC Trim Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>TRIM_SEL</td><td><div style="word-wrap: break-word;"><b>Trim Frequency Selection
</b><br>
This bit is to enable the HIRC auto trim.
<br>
When setting this bit to 1, the HIRC auto trim function will trim HIRC to 22.1184 MHz automatically based on the LXT reference clock.
<br>
During auto trim operation, if LXT clock error is detected or trim retry limitation count reached, this field will be cleared to 0 automatically.
<br>
0 = HIRC auto trim function Disabled.
<br>
1 = HIRC auto trim function Enabled and HIRC trimmed to 22.1184 MHz.
<br>
</div></td></tr><tr><td>
[5:4]</td><td>TRIM_LOOP</td><td><div style="word-wrap: break-word;"><b>Trim Calculation Loop
</b><br>
This field defines that trim value calculation is based on how many LXT clocks in.
<br>
For example, if TRIM_LOOP is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 LXT clock.
<br>
00 = Trim value calculation is based on average difference in 4 LXT clocks.
<br>
01 = Trim value calculation is based on average difference in 8 LXT clocks.
<br>
10 = Trim value calculation is based on average difference in 16 LXT clocks.
<br>
11 = Trim value calculation is based on average difference in 32 LXT clocks.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02700">2700</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="aa506a80cdcd8402609161d711bfcde56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa506a80cdcd8402609161d711bfcde56">&#9670;&nbsp;</a></span>IRCTRIMIER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::IRCTRIMIER</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IRCTRIMIER
</font><br><p> <font size="2">
Offset: 0x84  HIRC Trim Interrupt Enable Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>TRIM_FAIL_IEN</td><td><div style="word-wrap: break-word;"><b>Trim Failure Interrupt Enable Control
</b><br>
This bit controls if an interrupt will be triggered while HIRC trim value update limitation count is reached and HIRC frequency is still not locked on target frequency set by TRIM_SEL.
<br>
If this bit is high and TRIM_FAIL_INT is set during auto trim operation, an interrupt will be triggered to notify that HIRC trim value update limitation count is reached.
<br>
0 = TRIM_FAIL_INT status Disabled to trigger an interrupt to CPU.
<br>
1 = TRIM_FAIL_INT status Enabled to trigger an interrupt to CPU.
<br>
</div></td></tr><tr><td>
[2]</td><td>32K_ERR_IEN</td><td><div style="word-wrap: break-word;"><b>LXT Clock Error Interrupt Enable Control
</b><br>
This bit controls if CPU could get an interrupt while LXT clock is inaccurate during auto trim operation.
<br>
If this bit is high, and 32K_ERR_INT is set during auto trim operation, an interrupt will be triggered to notify the LXT clock frequency is inaccurate.
<br>
0 = 32K_ERR_INT status Disabled to trigger an interrupt to CPU.
<br>
1 = 32K_ERR_INT status Enabled to trigger an interrupt to CPU.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02701">2701</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="acc4f4419d8713b07c3ede187da4c274a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4f4419d8713b07c3ede187da4c274a">&#9670;&nbsp;</a></span>IRCTRIMISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::IRCTRIMISR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IRCTRIMISR
</font><br><p> <font size="2">
Offset: 0x88  HIRC Trim Interrupt Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>FREQ_LOCK</td><td><div style="word-wrap: break-word;"><b>HIRC Frequency Lock Status
</b><br>
This bit indicates the HIRC frequency locked in 22.1184 MHz.
<br>
This is a read only status bit and doesn't trigger any interrupt.
<br>
</div></td></tr><tr><td>
[1]</td><td>TRIM_FAIL_INT</td><td><div style="word-wrap: break-word;"><b>Trim Failure Interrupt Status
</b><br>
This bit indicates that HIRC trim value update limitation count reached and HIRC clock frequency still doesn't lock.
<br>
Once this bit is set, the auto trim operation stopped and TRIM_SEL will be cleared to 0 by hardware automatically.
<br>
If this bit is set and TRIM_FAIL_IEN is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.
<br>
Software can write 1 to clear this bit to 0.
<br>
0 = Trim value update limitation count is not reached.
<br>
1 = Trim value update limitation count is reached and HIRC frequency is still not locked.
<br>
</div></td></tr><tr><td>
[2]</td><td>32K_ERR_INT</td><td><div style="word-wrap: break-word;"><b>LXT Clock Error Interrupt Status
</b><br>
This bit indicates that LXT clock frequency is inaccuracy.
<br>
Once this bit is set, the auto trim operation stopped and TRIM_SEL will be cleared to 0 by hardware automatically.
<br>
If this bit is set and 32K_ERR_IEN is high, an interrupt will be triggered to notify the LXT clock frequency is inaccuracy.
<br>
Software can write 1 to clear this bit to 0.
<br>
0 = LXT clock frequency is accuracy.
<br>
1 = LXT clock frequency is inaccuracy.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02702">2702</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="af1703db134b6af85b089fb24527f9ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1703db134b6af85b089fb24527f9ae9">&#9670;&nbsp;</a></span>P0_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::P0_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">P0_MFP
</font><br><p> <font size="2">
Offset: 0x30  P0 Multiple Function and Input Type Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>P0_MFP</td><td><div style="word-wrap: break-word;"><b>P0 Multiple Function Selection
</b><br>
</div></td></tr><tr><td>
[8]</td><td>P0_ALT0</td><td><div style="word-wrap: break-word;"><b>P0.0 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[9]</td><td>P0_ALT1</td><td><div style="word-wrap: break-word;"><b>P0.1 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[12]</td><td>P0_ALT4</td><td><div style="word-wrap: break-word;"><b>P0.4 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[13]</td><td>P0_ALT5</td><td><div style="word-wrap: break-word;"><b>P0.5 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[14]</td><td>P0_ALT6</td><td><div style="word-wrap: break-word;"><b>P0.6 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[15]</td><td>P0_ALT7</td><td><div style="word-wrap: break-word;"><b>P0.7 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[23:16]</td><td>P0_TYPE</td><td><div style="word-wrap: break-word;"><b>P0[7:0] TTL Or Schmitt Trigger Function Enable Control
</b><br>
0 = P0[7:0]Select I/O input as TTL function.
<br>
1 = P0[7:0] Select I/O input as Schmitt Trigger function .
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02691">2691</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="ab79ddc89f5e3b8253388260889dc6a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79ddc89f5e3b8253388260889dc6a83">&#9670;&nbsp;</a></span>P1_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::P1_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">P1_MFP
</font><br><p> <font size="2">
Offset: 0x34  P1 Multiple Function and Input Type Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>P1_MFP</td><td><div style="word-wrap: break-word;"><b>P1 Multiple Function Selection
</b><br>
</div></td></tr><tr><td>
[8]</td><td>P1_ALT0</td><td><div style="word-wrap: break-word;"><b>P1.0 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[10]</td><td>P1_ALT2</td><td><div style="word-wrap: break-word;"><b>P1.2 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[11]</td><td>P1_ALT3</td><td><div style="word-wrap: break-word;"><b>P1.3 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[12]</td><td>P1_ALT4</td><td><div style="word-wrap: break-word;"><b>P1.4 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[13]</td><td>P1_ALT5</td><td><div style="word-wrap: break-word;"><b>P1.5 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[23:16]</td><td>P1_TYPE</td><td><div style="word-wrap: break-word;"><b>P1[7:0] TTL Or Schmitt Trigger Function Enable Control
</b><br>
0 = P1[7:0]Select I/O input as TTL function.
<br>
1 = P1[7:0] Select I/O input as Schmitt Trigger function .
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02692">2692</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="ab15d3c4cdaab63d4e0a501303a005d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15d3c4cdaab63d4e0a501303a005d0e">&#9670;&nbsp;</a></span>P2_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::P2_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">P2_MFP
</font><br><p> <font size="2">
Offset: 0x38  P2 Multiple Function and Input Type Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>P2_MFP</td><td><div style="word-wrap: break-word;"><b>P2 Multiple Function Selection
</b><br>
</div></td></tr><tr><td>
[10]</td><td>P2_ALT2</td><td><div style="word-wrap: break-word;"><b>P2.2 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[11]</td><td>P2_ALT3</td><td><div style="word-wrap: break-word;"><b>P2.3 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[12]</td><td>P2_ALT4</td><td><div style="word-wrap: break-word;"><b>P2.4 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[13]</td><td>P2_ALT5</td><td><div style="word-wrap: break-word;"><b>P2.5 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[14]</td><td>P2_ALT6</td><td><div style="word-wrap: break-word;"><b>P2.6 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[23:16]</td><td>P2_TYPE</td><td><div style="word-wrap: break-word;"><b>P2[7:0] TTL Or Schmitt Trigger Function Enable Control
</b><br>
0 = P2[7:0]Select I/O input as TTL function.
<br>
1 = P2[7:0] Select I/O input as Schmitt Trigger function .
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02693">2693</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a02e963f7ef36cb80a29e07f0c896da2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e963f7ef36cb80a29e07f0c896da2d">&#9670;&nbsp;</a></span>P3_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::P3_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">P3_MFP
</font><br><p> <font size="2">
Offset: 0x3C  P3 Multiple Function and Input Type Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>P3_MFP</td><td><div style="word-wrap: break-word;"><b>P3 Multiple Function Selection
</b><br>
</div></td></tr><tr><td>
[8]</td><td>P3_ALT0</td><td><div style="word-wrap: break-word;"><b>P3.0 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[9]</td><td>P3_ALT1</td><td><div style="word-wrap: break-word;"><b>P3.1 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[10]</td><td>P3_ALT2</td><td><div style="word-wrap: break-word;"><b>P3.2 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[12]</td><td>P3_ALT4</td><td><div style="word-wrap: break-word;"><b>P3.4 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[13]</td><td>P3_ALT5</td><td><div style="word-wrap: break-word;"><b>P3.5 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[14]</td><td>P3_ALT6</td><td><div style="word-wrap: break-word;"><b>P3.6 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[23:16]</td><td>P3_TYPE</td><td><div style="word-wrap: break-word;"><b>P3[7:0] TTL Or Schmitt Trigger Function Enable Control
</b><br>
0 = P3[7:0]Select I/O input as TTL function.
<br>
1 = P3[7:0] Select I/O input as Schmitt Trigger function .
<br>
</div></td></tr><tr><td>
[24]</td><td>P32CPP1</td><td><div style="word-wrap: break-word;"><b>P3.2 Alternate Function Selection Extension
</b><br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02694">2694</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="ad086af8759866118e50e71756e605f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad086af8759866118e50e71756e605f16">&#9670;&nbsp;</a></span>P4_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::P4_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">P4_MFP
</font><br><p> <font size="2">
Offset: 0x40  P4 Multiple Function and Input Type Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>P4_MFP</td><td><div style="word-wrap: break-word;"><b>P4 Multiple Function Selection
</b><br>
</div></td></tr><tr><td>
[14]</td><td>P4_ALT6</td><td><div style="word-wrap: break-word;"><b>P4.6 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[15]</td><td>P4_ALT7</td><td><div style="word-wrap: break-word;"><b>P4.7 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[23:16]</td><td>P4_TYPE</td><td><div style="word-wrap: break-word;"><b>P4[7:0] TTL Or Schmitt Trigger Function Enable Control
</b><br>
0 = P4[7:0]Select I/O input as TTL function.
<br>
1 = P4[7:0] Select I/O input as Schmitt Trigger function .
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02695">2695</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a3e3e0d273e94aada01adfad33c9a71b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3e0d273e94aada01adfad33c9a71b9">&#9670;&nbsp;</a></span>P5_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::P5_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">P5_MFP
</font><br><p> <font size="2">
Offset: 0x44  P5 Multiple Function and Input Type Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>P5_MFP</td><td><div style="word-wrap: break-word;"><b>P5 Multiple Function Selection
</b><br>
</div></td></tr><tr><td>
[8]</td><td>P5_ALT0</td><td><div style="word-wrap: break-word;"><b>P5.0 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[9]</td><td>P5_ALT1</td><td><div style="word-wrap: break-word;"><b>P5.1 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[10]</td><td>P5_ALT2</td><td><div style="word-wrap: break-word;"><b>P5.2 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[11]</td><td>P5_ALT3</td><td><div style="word-wrap: break-word;"><b>P5.3 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[12]</td><td>P5_ALT4</td><td><div style="word-wrap: break-word;"><b>P5.4 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[13]</td><td>P5_ALT5</td><td><div style="word-wrap: break-word;"><b>P5.5 Alternate Function Selection
</b><br>
</div></td></tr><tr><td>
[23:16]</td><td>P5_TYPE</td><td><div style="word-wrap: break-word;"><b>P5[7:0] TTL Or Schmitt Trigger Function Enable Control
</b><br>
0 = P5[7:0]Select I/O input as TTL function.
<br>
1 = P5[7:0] Select I/O input as Schmitt Trigger function .
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02696">2696</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="af8a567a29d2750af51eb932b7664baa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a567a29d2750af51eb932b7664baa3">&#9670;&nbsp;</a></span>PDID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::PDID</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PDID
</font><br><p> <font size="2">
Offset: 0x00  Part Device Identification Number Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[31:0]</td><td>PDID</td><td><div style="word-wrap: break-word;"><b>Product Device Identification Number
</b><br>
This register reflects the device part number code.
<br>
Software can read this register to identify which device is used.
<br>
For example, the MINI51LDE PDID code is "0x20205100".
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02680">2680</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a55058438f0f5bd20b75de051e8bbef49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55058438f0f5bd20b75de051e8bbef49">&#9670;&nbsp;</a></span>RegLockAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::RegLockAddr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">RegLockAddr
</font><br><p> <font size="2">
Offset: 0x100  Register Write-Protection Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RegUnLock</td><td><div style="word-wrap: break-word;"><b>Register Write-protection Disable Index (Read Only)
</b><br>
0 = Write-protection Enabled for writing protected registers.
<br>
Any write to the protected register is ignored.
<br>
1 = Write-protection Disabled for writing protected registers.
<br>
The Protected registers are:
<br>
IPRSTC1 (0x5000_0008)
<br>
BODCTL (0x5000_0018)
<br>
PWRCON (0x5000_0200), bit[6] is not protected for power wake-up interrupt clear
<br>
APBCLK (0x5000_0208), bit[0] watchdog clock enable only
<br>
CLKSEL0 (0x5000_0210)
<br>
CLKSEL1 (0x5000_0214), bit[1:0] Watchdog clock source select only
<br>
NMI_SEL (0x5000_0380), bit[8] NMI interrupt enable only
<br>
ISPCON (0x5000_C000)
<br>
ISPTRG (0x5000_C010)
<br>
WTCR (0x4000_4000)
<br>
Note: The bits which are write-protected will be noted as" (Write Protect)" beside the description.
<br>
</div></td></tr><tr><td>
[7:0]</td><td>REGWRPROT</td><td><div style="word-wrap: break-word;"><b>Register Write-protection Code (Write Only)
</b><br>
Some registers have write-protection function.
<br>
Writing these registers have to disable the protected function by writing the sequence value 0x59, 0x16, 0x88 to this field.
<br>
After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protection registers can be normal write.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02706">2706</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="aafe5bb4fd7cc545439b3ea01246d1524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe5bb4fd7cc545439b3ea01246d1524">&#9670;&nbsp;</a></span>RSTSRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GCR_T::RSTSRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">RSTSRC
</font><br><p> <font size="2">
Offset: 0x04  System Reset Source Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RSTS_POR</td><td><div style="word-wrap: break-word;"><b>Power-on Reset Flag
</b><br>
The RSTS_POR flag is set by the "reset signal", which is from the Power-On Reset (POR) controller or bit CHIP_RST (IPRSTC1[0]), to indicate the previous reset source.
<br>
0 = No reset from POR or CHIP_RST.
<br>
1 = Power-on-Reset (POR) or CHIP_RST had issued the reset signal to reset the system.
<br>
Note: Software can write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[1]</td><td>RSTS_RESET</td><td><div style="word-wrap: break-word;"><b>Reset Pin Reset Flag
</b><br>
The RSTS_RESET flag is set by the "reset signal" from the /RESET pin to indicate the previous reset source.
<br>
0 = No reset from pin /RESET pin.
<br>
1 = The /RESET pin had issued the reset signal to reset the system.
<br>
Note: Software can write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[2]</td><td>RSTS_WDT</td><td><div style="word-wrap: break-word;"><b>Watchdog Reset Flag
</b><br>
The RSTS_WDT flag is set by the "reset signal" from the Watchdog timer to indicate the previous reset source.
<br>
0 = No reset from Watchdog timer.
<br>
1 = The Watchdog timer had issued the reset signal to reset the system.
<br>
Note: Software can write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[4]</td><td>RSTS_BOD</td><td><div style="word-wrap: break-word;"><b>Brown-out Detector Reset Flag
</b><br>
The RSTS_BOD flag is set by the "reset signal" from the Brown-out Detector to indicate the previous reset source.
<br>
0 = No reset from BOD.
<br>
1 = The BOD had issued the reset signal to reset the system.
<br>
Note: Software can write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[5]</td><td>RSTS_MCU</td><td><div style="word-wrap: break-word;"><b>MCU Reset Flag
</b><br>
The RSTS_MCU flag is set by the "reset signal" from the Cortex-M0 core to indicate the previous reset source.
<br>
0 = No reset from Cortex-M0.
<br>
1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to bit SYSRESETREQ (AIRCR[2]), Application Interrupt and Reset Control Register, address = 0xE000ED0C in system control registers of Cortex-M0 core.
<br>
Note: Software can write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[7]</td><td>RSTS_CPU</td><td><div style="word-wrap: break-word;"><b>CPU Reset Flag
</b><br>
The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset Cortex-M0 core and Flash memory controller (FMC).
<br>
0 = No reset from CPU.
<br>
1 = Cortex-M0 core and FMC are reset by software setting CPU_RST to 1.
<br>
Note: Software can write 1 to clear this bit to 0.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l02681">2681</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Device/Nuvoton/Mini51Series/Include/<a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 6 2019 14:41:13 for Mini51 BSP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
