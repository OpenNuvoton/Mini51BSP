<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mini51 BSP: UART_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="M0Banner_v2.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mini51 BSP
   &#160;<span id="projectnumber">V3.02.002</span>
   </div>
   <div id="projectbrief">The Board Support Package for Mini51 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">UART_T Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ab1e973818ec03f75c69fd24f5b8f322a"><td class="memItemLeft" >union {</td></tr>
<tr class="memitem:afb202ba20ff0e10d790dd3ac19a71e17"><td class="memItemLeft" >&#160;&#160;&#160;__I uint32_t&#160;&#160;&#160;<a class="el" href="struct_u_a_r_t___t.html#a413676eb36f2215c4a51372f33a68ee3">RBR</a></td></tr>
<tr class="separator:afb202ba20ff0e10d790dd3ac19a71e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5489af8843052e256eb75fbfd1745ad8"><td class="memItemLeft" >&#160;&#160;&#160;__O uint32_t&#160;&#160;&#160;<a class="el" href="struct_u_a_r_t___t.html#a1ff3c208c8ca5807684ff84d35bb3e03">THR</a></td></tr>
<tr class="separator:a5489af8843052e256eb75fbfd1745ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e973818ec03f75c69fd24f5b8f322a"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:ab1e973818ec03f75c69fd24f5b8f322a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b5663f0b3de889caac30060643a383"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#ad1b5663f0b3de889caac30060643a383">IER</a></td></tr>
<tr class="separator:ad1b5663f0b3de889caac30060643a383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b85a7395e434cbf4bee23062a032585"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a1b85a7395e434cbf4bee23062a032585">FCR</a></td></tr>
<tr class="separator:a1b85a7395e434cbf4bee23062a032585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024625ad6f6776b46d26d7b18adb7b99"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a024625ad6f6776b46d26d7b18adb7b99">LCR</a></td></tr>
<tr class="separator:a024625ad6f6776b46d26d7b18adb7b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6121886bb041a9f1c63911dcdbd8510"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#ae6121886bb041a9f1c63911dcdbd8510">MCR</a></td></tr>
<tr class="separator:ae6121886bb041a9f1c63911dcdbd8510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4ced4b447af04fdadf9f9c904cb404"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a8b4ced4b447af04fdadf9f9c904cb404">MSR</a></td></tr>
<tr class="separator:a8b4ced4b447af04fdadf9f9c904cb404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f974990cecd0cd869698e411fb1387"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a33f974990cecd0cd869698e411fb1387">FSR</a></td></tr>
<tr class="separator:a33f974990cecd0cd869698e411fb1387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7af8ed45c1e8b85d8fb1ecd6bcb2105"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#ac7af8ed45c1e8b85d8fb1ecd6bcb2105">ISR</a></td></tr>
<tr class="separator:ac7af8ed45c1e8b85d8fb1ecd6bcb2105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a280db5df6e6fa46d77fe99a4d143b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a27a280db5df6e6fa46d77fe99a4d143b">TOR</a></td></tr>
<tr class="separator:a27a280db5df6e6fa46d77fe99a4d143b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60210f63317de5a3432d775dbc4c9209"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a60210f63317de5a3432d775dbc4c9209">BAUD</a></td></tr>
<tr class="separator:a60210f63317de5a3432d775dbc4c9209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cada1c17dd9fd3825ce247a6f88180"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#ab5cada1c17dd9fd3825ce247a6f88180">IRCR</a></td></tr>
<tr class="separator:ab5cada1c17dd9fd3825ce247a6f88180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda0c1126e0c2c119c3768a67cc1ed35"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#abda0c1126e0c2c119c3768a67cc1ed35">ALT_CSR</a></td></tr>
<tr class="separator:abda0c1126e0c2c119c3768a67cc1ed35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7601c8d1529c8f59347b7a0089709f08"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a7601c8d1529c8f59347b7a0089709f08">FUN_SEL</a></td></tr>
<tr class="separator:a7601c8d1529c8f59347b7a0089709f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
Memory Mapped Structure for UART Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l08567">8567</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="ab1e973818ec03f75c69fd24f5b8f322a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e973818ec03f75c69fd24f5b8f322a">&#9670;&nbsp;</a></span>@1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union { ... } </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abda0c1126e0c2c119c3768a67cc1ed35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda0c1126e0c2c119c3768a67cc1ed35">&#9670;&nbsp;</a></span>ALT_CSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::ALT_CSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ALT_CSR
</font><br><p> <font size="2">
Offset: 0x2C  UART Alternate Control/Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[8]</td><td>RS485_NMM</td><td><div style="word-wrap: break-word;"><b>RS-485 Normal Multi-drop Operation Mode (NMM) Control
</b><br>
0 = RS-485 Normal Multi-drop Operation Mode (NMM) Disabled.
<br>
1 = RS-485 Normal Multi-drop Operation Mode (NMM) Enabled.
<br>
Note: This bit cannot be active with RS485_AAD operation mode.
<br>
</div></td></tr><tr><td>
[9]</td><td>RS485_AAD</td><td><div style="word-wrap: break-word;"><b>RS-485 Auto Address Detection Operation Mode (AAD)
</b><br>
0 = RS-485 Auto Address Detection Operation Mode (AAD) Disabled.
<br>
1 = RS-485 Auto Address Detection Operation Mode (AAD) Enabled.
<br>
Note: This bit cannot be active with RS485_NMM operation mode.
<br>
</div></td></tr><tr><td>
[10]</td><td>RS485_AUD</td><td><div style="word-wrap: break-word;"><b>RS-485 Auto Direction Mode (AUD) Control
</b><br>
0 = RS-485 Auto Address Detection Operation Mode (AAD) Disabled.
<br>
1 = RS-485 Auto Address Detection Operation Mode (AAD) Enabled.
<br>
Note: This bit cannot be active with RS485_NMM operation mode.
<br>
</div></td></tr><tr><td>
[15]</td><td>RS485_ADD_EN</td><td><div style="word-wrap: break-word;"><b>RS-485 Address Detection Enable Control
</b><br>
This bit is used to enable RS-485 Address Detection mode.
<br>
0 = RS-485 address detection mode Disabled.
<br>
1 = RS-485 address detection mode Enabled.
<br>
Note: This field is used for RS-485 any operation mode.
<br>
</div></td></tr><tr><td>
[31:24]</td><td>ADDR_MATCH</td><td><div style="word-wrap: break-word;"><b>Address Match Value
</b><br>
This field contains the RS-485 address match values.
<br>
Note: This field is used for RS-485 auto address detection mode.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09466">9466</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a60210f63317de5a3432d775dbc4c9209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60210f63317de5a3432d775dbc4c9209">&#9670;&nbsp;</a></span>BAUD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::BAUD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">BAUD
</font><br><p> <font size="2">
Offset: 0x24  UART Baud Rate Divisor Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>BRD</td><td><div style="word-wrap: break-word;"><b>Baud Rate Divider
</b><br>
The field indicates the baud rate divider.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>DIVIDER_X</td><td><div style="word-wrap: break-word;"><b>Divider X
</b><br>
The baud rate divider M = X+1.
<br>
</div></td></tr><tr><td>
[28]</td><td>DIV_X_ONE</td><td><div style="word-wrap: break-word;"><b>Divider X Equal 1
</b><br>
0 = Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must >= 8).
<br>
1 = Divider M = 1 (the equation of M = 1, but BRD [15:0] must >= 8).
<br>
Refer to section "UART Controller Baud Rate Generator" for more information.
<br>
</div></td></tr><tr><td>
[29]</td><td>DIV_X_EN</td><td><div style="word-wrap: break-word;"><b>Divider X Enable Control
</b><br>
The BRD = Baud Rate Divider, and the baud rate equation is:  Baud Rate = Clock / [M * (BRD + 2)], The default value of M is 16.
<br>
0 = Divider X Disabled (the equation of M = 16).
<br>
1 = Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must >= 8).
<br>
Note: When in IrDA mode, this bit must be disabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09464">9464</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a1b85a7395e434cbf4bee23062a032585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b85a7395e434cbf4bee23062a032585">&#9670;&nbsp;</a></span>FCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::FCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FCR
</font><br><p> <font size="2">
Offset: 0x08  UART FIFO Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>RFR</td><td><div style="word-wrap: break-word;"><b>RX Field Software Reset
</b><br>
When RX_RST is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
<br>
0 = No effect.
<br>
1 = The RX internal state machine and pointers reset.
<br>
Note: This bit will auto clear needs at least 3 UART Controller peripheral clock cycles.
<br>
</div></td></tr><tr><td>
[2]</td><td>TFR</td><td><div style="word-wrap: break-word;"><b>TX Field Software Reset
</b><br>
When TX_RST is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
<br>
0 = No effect.
<br>
1 = The TX internal state machine and pointers reset.
<br>
Note: This bit will auto clear needs at least 3 UART Controller peripheral clock cycles.
<br>
</div></td></tr><tr><td>
[7:4]</td><td>RFITL</td><td><div style="word-wrap: break-word;"><b>RX FIFO Interrupt (RDA_INT) Trigger Level
</b><br>
When the number of bytes in the receive FIFO equals the RFITL then the RDA_IF will be set (if RDA_IEN in UA_IER register is enable, an interrupt will generated).
<br>
0000 = RX FIFO Interrupt Trigger Level is 1 byte.
<br>
0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
<br>
0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
<br>
0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
<br>
Other = Reserved.
<br>
</div></td></tr><tr><td>
[8]</td><td>RX_DIS</td><td><div style="word-wrap: break-word;"><b>Receiver Disable Control
</b><br>
The receiver is disabled or not (setting 1 to disable the receiver).
<br>
0 = Receiver Enabled.
<br>
1 = Receiver Disabled.
<br>
Note1: This field is only used for RS-485 Normal Multi-drop mode.
<br>
It should be programmed firstly to avoid receiving unknown data before RS-485_NMM (UA_ALT_CSR [8]) is programmed.
<br>
Note2: After RS-485 receives an address byte in RS-485 Normal Multi-drop mode, this bit (RX_DIS) will be cleared to "0" by hardware.
<br>
</div></td></tr><tr><td>
[19:16]</td><td>RTS_TRI_LEV</td><td><div style="word-wrap: break-word;"><b>RTS Trigger Level (For Auto-flow Control Use)
</b><br>
0000 = RTS Trigger Level is 1 byte.
<br>
0001 = RTS Trigger Level is 4 bytes.
<br>
0010 = RTS Trigger Level is 8 bytes.
<br>
0011 = RTS Trigger Level is 14 bytes.
<br>
Other = Reserved.
<br>
Note: This field is used for RTS auto-flow control.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09457">9457</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a33f974990cecd0cd869698e411fb1387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f974990cecd0cd869698e411fb1387">&#9670;&nbsp;</a></span>FSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::FSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FSR
</font><br><p> <font size="2">
Offset: 0x18  UART FIFO Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RX_OVER_IF</td><td><div style="word-wrap: break-word;"><b>RX Overflow Error Interrupt Flag
</b><br>
This bit is set when RX FIFO overflow.
<br>
If the number of bytes of received data is greater than RX_FIFO (UA_RBR) size 16 bytes, this bit will be set.
<br>
0 = RX FIFO is not overflow.
<br>
1 = RX FIFO is overflow.
<br>
Note: This bit is cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[3]</td><td>RS485_ADD_DETF</td><td><div style="word-wrap: break-word;"><b>RS-485 Address Byte Detection Flag
</b><br>
This bit is set to 1 while RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode and receive detect a data with an address bit (bit 9 = 1).
<br>
Note1: This field is used for RS-485 function mode.
<br>
Note2: This bit is cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[4]</td><td>PEF</td><td><div style="word-wrap: break-word;"><b>Parity Error Flag (Read Only)
</b><br>
This bit is set to logic 1 whenever the received character does not have a valid "parity bit".
<br>
0 = No parity error is generated.
<br>
1 = Parity error is generated.Note: This bit is read only, but can be cleared by writing '1' to it .
<br>
</div></td></tr><tr><td>
[5]</td><td>FEF</td><td><div style="word-wrap: break-word;"><b>Framing Error Flag (Read Only)
</b><br>
This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit follows the last data bit or parity bit is detected as as logic 0).
<br>
0 = No framing error is generated.
<br>
1 = Framing error is generated.
<br>
Note: This bit is read only, but can be cleared by writing '1' to it .
<br>
</div></td></tr><tr><td>
[6]</td><td>BIF</td><td><div style="word-wrap: break-word;"><b>Break Interrupt Flag (Read Only)
</b><br>
This bit is set to logic 1 whenever the received data input (RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).
<br>
0 = No Break interrupt is generated.
<br>
1 = Break interrupt is generated.
<br>
Note: This bit is read only, but software can write 1 to clear it.
<br>
</div></td></tr><tr><td>
[13:8]</td><td>RX_POINTER</td><td><div style="word-wrap: break-word;"><b>RX FIFO Pointer (Read Only)
</b><br>
This field indicates the RX FIFO Buffer Pointer.
<br>
When UART receives one byte from external device, RX_POINTER increases one.
<br>
When one byte of RX FIFO is read by CPU, RX_POINTER decreases one.
<br>
The Maximum value shown in RX_POINTER is 15.
<br>
When the using level of RX FIFO Buffer equal to 16, the RX_FULL bit is set to 1 and RX_POINTER will show 0.
<br>
As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 15.
<br>
</div></td></tr><tr><td>
[14]</td><td>RX_EMPTY</td><td><div style="word-wrap: break-word;"><b>Receiver FIFO Empty (Read Only)
</b><br>
This bit initiate RX FIFO empty or not.
<br>
0 = RX FIFO is not empty.
<br>
1 = RX FIFO is empty.
<br>
Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high.
<br>
It will be cleared when UART receives any new data.
<br>
</div></td></tr><tr><td>
[15]</td><td>RX_FULL</td><td><div style="word-wrap: break-word;"><b>Receiver FIFO Full (Read Only)
</b><br>
This bit initiates RX FIFO full or not.
<br>
0 = RX FIFO is not full.
<br>
1 = RX FIFO is full.
<br>
Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
<br>
</div></td></tr><tr><td>
[21:16]</td><td>TX_POINTER</td><td><div style="word-wrap: break-word;"><b>TX FIFO Pointer (Read Only)
</b><br>
This field indicates the TX FIFO Buffer Pointer.
<br>
When CPU writes one byte into UA_THR, TX_POINTER increases one.
<br>
When one byte of TX FIFO is transferred to Transmitter Shift Register, TX_POINTER decreases one.
<br>
The Maximum value shown in TX_POINTER is 15.
<br>
When the using level of TX FIFO Buffer equal to 16, the TX_FULL bit is set to 1 and TX_POINTER will show 0.
<br>
As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 15.
<br>
</div></td></tr><tr><td>
[22]</td><td>TX_EMPTY</td><td><div style="word-wrap: break-word;"><b>Transmitter FIFO Empty (Read Only)
</b><br>
This bit indicates TX FIFO is empty or not.
<br>
0 = TX FIFO is not empty.
<br>
1 = TX FIFO is empty.
<br>
Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
<br>
It will be cleared when writing data into THR (TX FIFO not empty).
<br>
</div></td></tr><tr><td>
[23]</td><td>TX_FULL</td><td><div style="word-wrap: break-word;"><b>Transmitter FIFO Full (Read Only)
</b><br>
This bit indicates TX FIFO full or not.
<br>
0 = TX FIFO is not full.
<br>
1 = TX FIFO is full.
<br>
Note: This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
<br>
</div></td></tr><tr><td>
[24]</td><td>TX_OVER_IF</td><td><div style="word-wrap: break-word;"><b>TX Overflow Error Interrupt Flag
</b><br>
If TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to  logic 1.
<br>
0 = TX FIFO is not overflow.
<br>
1 = TX FIFO is overflow.
<br>
Note: This bit is cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[28]</td><td>TE_FLAG</td><td><div style="word-wrap: break-word;"><b>Transmitter Empty Flag (Read Only)
</b><br>
This bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.
<br>
0 = TX FIFO is not empty.
<br>
1 = TX FIFO is empty and the STOP bit of the last byte has been transmitted.
<br>
Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09461">9461</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a7601c8d1529c8f59347b7a0089709f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7601c8d1529c8f59347b7a0089709f08">&#9670;&nbsp;</a></span>FUN_SEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::FUN_SEL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FUN_SEL
</font><br><p> <font size="2">
Offset: 0x30  UART Function Select Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1:0]</td><td>FUN_SEL</td><td><div style="word-wrap: break-word;"><b>Function Selection
</b><br>
00 = UART function mode.
<br>
01 = Reserved.
<br>
10 = IrDA function mode.
<br>
11 = RS-485 function mode.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09467">9467</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="ad1b5663f0b3de889caac30060643a383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b5663f0b3de889caac30060643a383">&#9670;&nbsp;</a></span>IER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::IER</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IER
</font><br><p> <font size="2">
Offset: 0x04  UART Interrupt Enable Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RDA_IEN</td><td><div style="word-wrap: break-word;"><b>Receive Data Available Interrupt Enable Control
</b><br>
0 = RDA_INT Masked off.
<br>
1 = RDA_INT Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>THRE_IEN</td><td><div style="word-wrap: break-word;"><b>Transmit Holding Register Empty Interrupt Enable Control
</b><br>
0 = THRE_INT Masked off.
<br>
1 = THRE_INT Enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>RLS_IEN</td><td><div style="word-wrap: break-word;"><b>Receive Line Status Interrupt Enable Control
</b><br>
0 = RLS_INT Masked off.
<br>
1 = RLS_INT Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>MODEM_IEN</td><td><div style="word-wrap: break-word;"><b>Modem Status Interrupt Enable Control
</b><br>
0 = MODEM_INT Masked off.
<br>
1 = MODEM_INT Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>RTO_IEN</td><td><div style="word-wrap: break-word;"><b>RX Time-out Interrupt Enable Control
</b><br>
0 = TOUT_INT Masked off.
<br>
1 = TOUT_INT Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>BUF_ERR_IEN</td><td><div style="word-wrap: break-word;"><b>Buffer Error Interrupt Enable Control
</b><br>
0 = INT_BUF_ERR Masked Disabled.
<br>
1 = INT_BUF_ERR Enabled.
<br>
</div></td></tr><tr><td>
[6]</td><td>WAKE_EN</td><td><div style="word-wrap: break-word;"><b>Wake-up CPU Function Enable Control
</b><br>
0 = UART wake-up function Disabled.
<br>
1 = UART Wake-up function Enabled.
<br>
Note: when the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode.
<br>
</div></td></tr><tr><td>
[11]</td><td>TIME_OUT_EN</td><td><div style="word-wrap: break-word;"><b>Time-out Counter Enable Control
</b><br>
0 = Time-out counter Disabled.
<br>
1 = Time-out counter Enabled.
<br>
</div></td></tr><tr><td>
[12]</td><td>AUTO_RTS_EN</td><td><div style="word-wrap: break-word;"><b>RTS Auto Flow Control Enable Control
</b><br>
0 = RTS auto flow control Disabled.
<br>
1 = RTS auto flow control Enabled.
<br>
Note: When RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.
<br>
</div></td></tr><tr><td>
[13]</td><td>AUTO_CTS_EN</td><td><div style="word-wrap: break-word;"><b>CTS Auto Flow Control Enable Control
</b><br>
0 = CTS auto flow control Disabled.
<br>
1 = CTS auto flow control Enabled.
<br>
Note: When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09456">9456</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="ab5cada1c17dd9fd3825ce247a6f88180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cada1c17dd9fd3825ce247a6f88180">&#9670;&nbsp;</a></span>IRCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::IRCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IRCR
</font><br><p> <font size="2">
Offset: 0x28  UART IrDA Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>TX_SELECT</td><td><div style="word-wrap: break-word;"><b>TX_SELECT
</b><br>
0 = IrDA receiver Enabled.
<br>
1 = IrDA transmitter Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>INV_TX</td><td><div style="word-wrap: break-word;"><b>INV_TX
</b><br>
0 = No inversion.
<br>
1 = Inverse TX output signal.
<br>
</div></td></tr><tr><td>
[6]</td><td>INV_RX</td><td><div style="word-wrap: break-word;"><b>INV_RX
</b><br>
0 = No inversion.
<br>
1 = Inverse RX input signal.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09465">9465</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="ac7af8ed45c1e8b85d8fb1ecd6bcb2105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7af8ed45c1e8b85d8fb1ecd6bcb2105">&#9670;&nbsp;</a></span>ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::ISR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ISR
</font><br><p> <font size="2">
Offset: 0x1C  UART Interrupt Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RDA_IF</td><td><div style="word-wrap: break-word;"><b>Receive Data Available Interrupt Flag (Read Only)
</b><br>
When the number of bytes in the RX FIFO equals the RFITL then the RDA_IF will be set.
<br>
If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.
<br>
0 = No RDA interrupt flag is generated.
<br>
1 = RDA interrupt flag is generated.
<br>
Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL).
<br>
</div></td></tr><tr><td>
[1]</td><td>THRE_IF</td><td><div style="word-wrap: break-word;"><b>Transmit Holding Register Empty Interrupt Flag (Read Only)
</b><br>
This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
<br>
If THRE_IEN (UA_IER [1]) is enabled, the THRE interrupt will be generated.
<br>
0 = No THRE interrupt flag is generated.
<br>
1 = THRE interrupt flag is generated.
<br>
Note: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).
<br>
</div></td></tr><tr><td>
[2]</td><td>RLS_IF</td><td><div style="word-wrap: break-word;"><b>Receive Line Interrupt Flag (Read Only)
</b><br>
This bit is set when the RX receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set).
<br>
If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.
<br>
0 = No RLS interrupt flag is generated.
<br>
1 = RLS interrupt flag is generated.
<br>
Note1: In RS-485 function mode, this field is set including "receiver detect and received address byte character (bit 9 = 1) bit".
<br>
At the same time, the bit of RS485_ADD_DETF (UA_FSR[3]) is also set.
<br>
Note2: This bit is read only and reset to 0 when all bits of BIF, FEF, PEF and RS485_ADD_DETF are cleared.
<br>
</div></td></tr><tr><td>
[3]</td><td>MODEM_IF</td><td><div style="word-wrap: break-word;"><b>MODEM Interrupt Flag (Read Only)
</b><br>
This bit is set when the CTS pin has state change (DCTSF = 1).
<br>
If UA_IER [MODEM_IEN] is enabled, the Modem interrupt will be generated.
<br>
0 = No Modem interrupt flag is generated.
<br>
1 = Modem interrupt flag is generated.
<br>
Note: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.
<br>
</div></td></tr><tr><td>
[4]</td><td>TOUT_IF</td><td><div style="word-wrap: break-word;"><b>Time-out Interrupt Flag (Read Only)
</b><br>
This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC.
<br>
If RTO_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.
<br>
0 = No Time-out interrupt flag is generated.
<br>
1 = Time-out interrupt flag is generated.
<br>
Note: This bit is read only and user can read UA_RBR (RX is in active) to clear it.
<br>
</div></td></tr><tr><td>
[5]</td><td>BUF_ERR_IF</td><td><div style="word-wrap: break-word;"><b>Buffer Error Interrupt Flag (Read Only)
</b><br>
This bit is set when the TX/RX FIFO overflow flag (TX_OVER_IF or RX_OVER_IF) is set.
<br>
When BUF_ERR_IF is set, the transfer is not correct.
<br>
If BUF_ERR_IEN (UA_IER [5]) is enabled, the buffer error interrupt will be generated.
<br>
0 = No buffer error interrupt flag is generated.
<br>
1 = Buffer error interrupt flag is generated.
<br>
Note: This bit is read only and reset to 0 when all bits of TX_OVER_IF and RX_OVER_IF are cleared.
<br>
</div></td></tr><tr><td>
[8]</td><td>RDA_INT</td><td><div style="word-wrap: break-word;"><b>Receive Data Available Interrupt Indicator (Read Only)
</b><br>
This bit is set if RDA_IEN and RDA_IF are both set to 1.
<br>
This bit is set if RDA_IEN and RDA_IF are both set to 1.
<br>
0 = No RDA interrupt is generated.
<br>
1 = RDA interrupt is generated.
<br>
</div></td></tr><tr><td>
[9]</td><td>THRE_INT</td><td><div style="word-wrap: break-word;"><b>Transmit Holding Register Empty Interrupt Indicator (Read Only)
</b><br>
This bit is set if THRE_IEN and THRE_IF are both set to 1.
<br>
0 = No THRE interrupt is generated.
<br>
1 = THRE interrupt is generated.
<br>
</div></td></tr><tr><td>
[10]</td><td>RLS_INT</td><td><div style="word-wrap: break-word;"><b>Receive Line Status Interrupt (Read Only)
</b><br>
This bit is set if RLS_IEN and RLS_IF are both set to 1.
<br>
0 = No RLS interrupt is generated.
<br>
1 = RLS interrupt is generated.
<br>
</div></td></tr><tr><td>
[11]</td><td>MODEM_INT</td><td><div style="word-wrap: break-word;"><b>MODEM Status Interrupt Indicator (Read Only)
</b><br>
This bit is set if MODEM_IEN and MODEM_IF are both set to 1.
<br>
0 = No Modem interrupt is generated.
<br>
1 = Modem interrupt is generated.
<br>
</div></td></tr><tr><td>
[12]</td><td>TOUT_INT</td><td><div style="word-wrap: break-word;"><b>Time-out Interrupt Indicator (Read Only)
</b><br>
This bit is set if RTO_IEN and TOUT_IF are both set to 1.
<br>
0 = No Time-out interrupt is generated.
<br>
1 = Time-out interrupt is generated.
<br>
</div></td></tr><tr><td>
[13]</td><td>BUF_ERR_INT</td><td><div style="word-wrap: break-word;"><b>Buffer Error Interrupt Indicator (Read Only)
</b><br>
This bit is set if BUF_ERR_IEN and BUF_ERR_IF are both set to 1.
<br>
0 = No buffer error interrupt is generated.
<br>
1 = buffer error interrupt is generated.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09462">9462</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a024625ad6f6776b46d26d7b18adb7b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024625ad6f6776b46d26d7b18adb7b99">&#9670;&nbsp;</a></span>LCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::LCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">LCR
</font><br><p> <font size="2">
Offset: 0x0C  UART Line Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1:0]</td><td>WLS</td><td><div style="word-wrap: break-word;"><b>Word Length Selection
</b><br>
00 = Word length is 5-bit.
<br>
01 = Word length is 6-bit.
<br>
10 = Word length is 7-bit.
<br>
11 = Word length is 8-bit.
<br>
</div></td></tr><tr><td>
[2]</td><td>NSB</td><td><div style="word-wrap: break-word;"><b>Number Of "STOP Bit"
</b><br>
0 = One "STOP bit" is generated in the transmitted data.
<br>
1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data.
<br>
When select 6-, 7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.
<br>
</div></td></tr><tr><td>
[3]</td><td>PBE</td><td><div style="word-wrap: break-word;"><b>Parity Bit Enable Control
</b><br>
0 = No parity bit.
<br>
1 = Parity bit is generated on each outgoing character and is checked on each incoming data.
<br>
</div></td></tr><tr><td>
[4]</td><td>EPE</td><td><div style="word-wrap: break-word;"><b>Even Parity Enable Control
</b><br>
0 = Odd number of logic 1's is transmitted and checked in each word.
<br>
1 = Even number of logic 1's is transmitted and checked in each word.
<br>
This bit has effect only when PBE (UA_LCR[3]) is set.
<br>
</div></td></tr><tr><td>
[5]</td><td>SPE</td><td><div style="word-wrap: break-word;"><b>Stick Parity Enable Control
</b><br>
0 = Stick parity Disabled.
<br>
1 = If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0.
<br>
If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1.
<br>
</div></td></tr><tr><td>
[6]</td><td>BCB</td><td><div style="word-wrap: break-word;"><b>Break Control Bit
</b><br>
When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0).
<br>
This bit acts only on TX and has no effect on the transmitter logic.
<br>
0 = Break control Disabled.
<br>
1 = Break control Enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09458">9458</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="ae6121886bb041a9f1c63911dcdbd8510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6121886bb041a9f1c63911dcdbd8510">&#9670;&nbsp;</a></span>MCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::MCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">MCR
</font><br><p> <font size="2">
Offset: 0x10  UART Modem Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>RTS</td><td><div style="word-wrap: break-word;"><b>RTS (Request-to-send) Signal Control
</b><br>
This bit is direct control internal RTS signal active or not, and then drive the RTS pin output with LEV_RTS bit configuration.
<br>
0 = RTS signal is active.
<br>
1 = RTS signal is inactive.
<br>
Note1: This RTS signal control bit is not effective when RTS auto-flow control (AUTO_RTS_EN) is enabled in UART function mode.
<br>
Note2: This RTS signal control bit is not effective when RS-485 auto direction mode (RS485_AUD) is enabled in RS-485 function mode.
<br>
</div></td></tr><tr><td>
[9]</td><td>LEV_RTS</td><td><div style="word-wrap: break-word;"><b>RTS Pin Active Level
</b><br>
This bit defines the active level state of RTS pin output.
<br>
0 = RTS pin output is high level active.
<br>
1 = RTS pin output is low level active.
<br>
Note1: Refer to and UART function mode.
<br>
Note2: Refer to and for RS-485 function mode.
<br>
</div></td></tr><tr><td>
[13]</td><td>RTS_ST</td><td><div style="word-wrap: break-word;"><b>RTS Pin State (Read Only)
</b><br>
This bit mirror from RTS pin output of voltage logic status.
<br>
0 = RTS pin output is low level voltage logic state.
<br>
1 = RTS pin output is high level voltage logic state.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09459">9459</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a8b4ced4b447af04fdadf9f9c904cb404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4ced4b447af04fdadf9f9c904cb404">&#9670;&nbsp;</a></span>MSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::MSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">MSR
</font><br><p> <font size="2">
Offset: 0x14  UART Modem Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>DCTSF</td><td><div style="word-wrap: break-word;"><b>Detect CTS State Change Flag
</b><br>
This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEM_IEN (UA_IER [3]) is set to 1.
<br>
0 = CTS input has not change state.
<br>
1 = CTS input has change state.
<br>
Note: This bit is cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[4]</td><td>CTS_ST</td><td><div style="word-wrap: break-word;"><b>CTS Pin Status (Read Only)
</b><br>
This bit mirror from CTS pin input of voltage logic status.
<br>
0 = CTS pin input is low level voltage logic state.
<br>
1 = CTS pin input is high level voltage logic state.
<br>
Note: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected.
<br>
</div></td></tr><tr><td>
[8]</td><td>LEV_CTS</td><td><div style="word-wrap: break-word;"><b>CTS Pin Active Level
</b><br>
This bit defines the active level state of CTS pin input.
<br>
0 = CTS pin input is high level active.
<br>
1 = CTS pin input is low level active.
<br>
Note: Refer to
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09460">9460</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a413676eb36f2215c4a51372f33a68ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413676eb36f2215c4a51372f33a68ee3">&#9670;&nbsp;</a></span>RBR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::RBR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">RBR
</font><br><p> <font size="2">
Offset: 0x00  UART Receive Buffer Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>RBR</td><td><div style="word-wrap: break-word;"><b>Receive Buffer Bits (Read Only)
</b><br>
By reading this register, the UART Controller will return an 8-bit data received from RX pin (LSB first).
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09453">9453</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a1ff3c208c8ca5807684ff84d35bb3e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff3c208c8ca5807684ff84d35bb3e03">&#9670;&nbsp;</a></span>THR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::THR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">THR
</font><br><p> <font size="2">
Offset: 0x00  UART Transmit Holding Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>THR</td><td><div style="word-wrap: break-word;"><b>Transmit Holding Bits
</b><br>
By writing to this register, the UART sends out an 8-bit data through the TX pin (LSB first).
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09454">9454</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a27a280db5df6e6fa46d77fe99a4d143b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a280db5df6e6fa46d77fe99a4d143b">&#9670;&nbsp;</a></span>TOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::TOR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TOR
</font><br><p> <font size="2">
Offset: 0x20  UART Time-out Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>TOIC</td><td><div style="word-wrap: break-word;"><b>Time-out Interrupt Comparator
</b><br>
The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word.
<br>
Once the content of time-out counter (TOUT_CNT) is equal to that of time-out interrupt comparator (TOIC), a receiver time-out interrupt (TOUT_INT) is generated if RTO_IEN (UA_IER [4]).
<br>
A new incoming data word or RX FIFO empty clears TOUT_INT.
<br>
In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC value should be set between 40 and 255.
<br>
So, for example, if TOIC is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
<br>
</div></td></tr><tr><td>
[15:8]</td><td>DLY</td><td><div style="word-wrap: break-word;"><b>TX Delay Time Value
</b><br>
This field is used to program the transfer delay time between the last stop bit and next start bit.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l09463">9463</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Device/Nuvoton/Mini51Series/Include/<a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 5 2020 14:31:45 for Mini51 BSP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
