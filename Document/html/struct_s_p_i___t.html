<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mini51 BSP: SPI_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="M0Banner_v2.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mini51 BSP
   &#160;<span id="projectnumber">V3.02.002</span>
   </div>
   <div id="projectbrief">The Board Support Package for Mini51 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">SPI_T Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a2cda79726f476ea64e73478bc0af6a77"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a2cda79726f476ea64e73478bc0af6a77">CNTRL</a></td></tr>
<tr class="separator:a2cda79726f476ea64e73478bc0af6a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a2d308eeea05b9ed0de03a6f15d80f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a94a2d308eeea05b9ed0de03a6f15d80f">DIVIDER</a></td></tr>
<tr class="separator:a94a2d308eeea05b9ed0de03a6f15d80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79443ba1b07520f8ec9024696858a190"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a79443ba1b07520f8ec9024696858a190">SSR</a></td></tr>
<tr class="separator:a79443ba1b07520f8ec9024696858a190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec4bee1b0ac67e6d48beca95d9a41bb"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a4ec4bee1b0ac67e6d48beca95d9a41bb">RX</a></td></tr>
<tr class="separator:a4ec4bee1b0ac67e6d48beca95d9a41bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfc54f0cd2fc536fb4e7eb0b8f9f18c"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#aacfc54f0cd2fc536fb4e7eb0b8f9f18c">TX</a></td></tr>
<tr class="separator:aacfc54f0cd2fc536fb4e7eb0b8f9f18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8cf81791eda50742fa64472ec47329"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a3d8cf81791eda50742fa64472ec47329">CNTRL2</a></td></tr>
<tr class="separator:a3d8cf81791eda50742fa64472ec47329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787691d1bc8968582b5e89b0f7e6e0f0"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a787691d1bc8968582b5e89b0f7e6e0f0">FIFO_CTL</a></td></tr>
<tr class="separator:a787691d1bc8968582b5e89b0f7e6e0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463a7dc0398240e38e1c356316e79a4d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a463a7dc0398240e38e1c356316e79a4d">STATUS</a></td></tr>
<tr class="separator:a463a7dc0398240e38e1c356316e79a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup SPI Serial Peripheral Interface Controller(SPI)
Memory Mapped Structure for SPI Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l07300">7300</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a2cda79726f476ea64e73478bc0af6a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cda79726f476ea64e73478bc0af6a77">&#9670;&nbsp;</a></span>CNTRL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::CNTRL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CNTRL
</font><br><p> <font size="2">
Offset: 0x00  SPI Control and Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>GO_BUSY</td><td><div style="word-wrap: break-word;"><b>SPI Transfer Control Bit And Busy Status
</b><br>
If FIFO mode is enabled, this bit will be controlled by hardware and is Read only.
<br>
If FIFO mode is disabled, during the data transfer, this bit keeps the value of 1.
<br>
As the transfer is finished, this bit will be cleared automatically.
<br>
0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
<br>
1 = In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master.
<br>
Note 1: When FIFO mode is disabled, all configurations should be ready before writing 1 to the GO_BUSY bit.
<br>
Note 2: In SPI Slave mode, if FIFO mode is disabled and the SPI bus clock is kept at idle state during a data transfer, the GO_BUSY bit will not be cleared to 0 when slave select signal goes to inactive state.
<br>
</div></td></tr><tr><td>
[1]</td><td>RX_NEG</td><td><div style="word-wrap: break-word;"><b>Receive On Negative Edge
</b><br>
0 = The received data input signal latched on the Rising edge of SPICLK.
<br>
1 = The received data input signal latched on the Falling edge of SPICLK.
<br>
</div></td></tr><tr><td>
[2]</td><td>TX_NEG</td><td><div style="word-wrap: break-word;"><b>Transmit On Negative Edge
</b><br>
0 = The transmitted data output signal is driven on the Rising edge of SPICLK.
<br>
1 = The transmitted data output signal is driven on the Falling edge of SPICLK.
<br>
</div></td></tr><tr><td>
[7:3]</td><td>TX_BIT_LEN</td><td><div style="word-wrap: break-word;"><b>Transmit Bit Length
</b><br>
This field specifies how many bits are transmitted in one transmit/receive.
<br>
The minimum bit length is 8 bits and can up to 32 bits.
<br>
TX_BIT_LEN = 0x08 ... 8 bits.
<br>
TX_BIT_LEN = 0x09 ... 9 bits.
<br>
.....
<br>
TX_BIT_LEN = 0x1F ... 31 bits.
<br>
TX_BIT_LEN = 0x00 ... 32 bits.
<br>
</div></td></tr><tr><td>
[10]</td><td>LSB</td><td><div style="word-wrap: break-word;"><b>LSB First
</b><br>
0 = The MSB is transmitted/received first.
<br>
1 = The LSB is transmitted/received first.
<br>
</div></td></tr><tr><td>
[11]</td><td>CLKP</td><td><div style="word-wrap: break-word;"><b>Clock Polarity
</b><br>
0 = SPICLK idle low.
<br>
1 = SPICLK idle high.
<br>
</div></td></tr><tr><td>
[15:12]</td><td>SP_CYCLE</td><td><div style="word-wrap: break-word;"><b>Suspend Interval (Master Only)
</b><br>
The four bits provide configurable suspend interval between two successive transactions in a transfer.
<br>
The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word.
<br>
The default value is 0x3.
<br>
The period of the suspend interval is obtained according to the following equation:
<br>
(SP_CYCLE[3:0] + 0.5) * period of SPICLK clock cycle
<br>
Example:
<br>
SP_CYCLE = 0x0 ... 0.5 SPICLK clock cycle.
<br>
SP_CYCLE = 0x1 ... 1.5 SPICLK clock cycle.
<br>
.....
<br>
SP_CYCLE = 0xE ... 14.5 SPICLK clock cycle.
<br>
SP_CYCLE = 0xF ... 15.5 SPICLK clock cycle.
<br>
</div></td></tr><tr><td>
[16]</td><td>IF</td><td><div style="word-wrap: break-word;"><b>Unit-transfer Interrupt Flag
</b><br>
0 = The transfer does not finish yet.
<br>
1 = The SPI controller has finished one unit transfer.
<br>
Note 1: This bit will be cleared by writing 1 to itself.
<br>
Note 2: It's a mutual mirror bit of SPI_STATUS[16].
<br>
</div></td></tr><tr><td>
[17]</td><td>IE</td><td><div style="word-wrap: break-word;"><b>Unit-transfer Interrupt Enable Control
</b><br>
0 = SPI unit-transfer interrupt Disabled.
<br>
1 = SPI unit-transfer interrupt Enabled.
<br>
</div></td></tr><tr><td>
[18]</td><td>SLAVE</td><td><div style="word-wrap: break-word;"><b>Slave Mode Control
</b><br>
0 = Master mode.
<br>
1 = Slave mode.
<br>
</div></td></tr><tr><td>
[19]</td><td>REORDER</td><td><div style="word-wrap: break-word;"><b>Byte Reorder Function
</b><br>
0 = Byte reorder function Disabled.
<br>
1 = Byte reorder function Enabled.
<br>
Note: This setting is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.
<br>
</div></td></tr><tr><td>
[21]</td><td>FIFO</td><td><div style="word-wrap: break-word;"><b>FIFO Mode Enable Control
</b><br>
0 = FIFO Mode Disabled.
<br>
1 = FIFO Mode Enabled.
<br>
Note 1: Before enabling FIFO mode, the other related settings should be set in advance.
<br>
Note 2: In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically after writing data into the 4-depth transmit FIFO.
<br>
When all data stored at transmit FIFO buffer are transferred, the GO_BUSY bit will back to 0.
<br>
</div></td></tr><tr><td>
[24]</td><td>RX_EMPTY</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Buffer Empty Indicator (Read Only)
</b><br>
0 = The receive FIFO buffer is not empty.
<br>
1 = The receive FIFO buffer is empty.
<br>
Note: It's a mutual mirror bit of SPI_CNTRL[24].
<br>
</div></td></tr><tr><td>
[25]</td><td>RX_FULL</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Buffer Full Indicator (Read Only)
</b><br>
0 = The receive FIFO buffer is not full.
<br>
1 = The receive FIFO buffer is full.
<br>
Note: It's a mutual mirror bit of SPI_STATUS[25]
<br>
</div></td></tr><tr><td>
[26]</td><td>TX_EMPTY</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Buffer Empty Indicator (Read Only)
</b><br>
0 = The transmit FIFO buffer is not empty.
<br>
1 = The transmit FIFO buffer is empty.
<br>
Note: It's a mutual mirror bit of SPI_STAUTS[26].
<br>
</div></td></tr><tr><td>
[27]</td><td>TX_FULL</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Buffer Full Indicator (Read Only)
</b><br>
0 =The transmit FIFO buffer is not full.
<br>
1 =The transmit FIFO buffer is full.
<br>
Note: It's a mutual mirror bit of SPI_STATUS[27].
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l07909">7909</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a3d8cf81791eda50742fa64472ec47329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8cf81791eda50742fa64472ec47329">&#9670;&nbsp;</a></span>CNTRL2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::CNTRL2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CNTRL2
</font><br><p> <font size="2">
Offset: 0x3C  SPI Control and Status Register 2
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[8]</td><td>NOSLVSEL</td><td><div style="word-wrap: break-word;"><b>Slave 3-wire Mode Enable Control (Slave Only)
</b><br>
The SPI controller work with 3-wire interface including SPICLK, SPI_MISO, and SPI_MOSI
<br>
0 = The controller is 4-wire bi-direction interface.
<br>
1 = The controller is 3-wire bi-direction interface in Slave mode.
<br>
The controller will be ready to transmit/receive data after the GO_BUSY bit is set to 1.
<br>
Note: In Slave 3-wire mode, the SS_LTRIG bit (SPI_SSR[4]) shall be set as 1.
<br>
</div></td></tr><tr><td>
[9]</td><td>SLV_ABORT</td><td><div style="word-wrap: break-word;"><b>Slave 3-wire Mode Abort Control Bit (Slave Only)
</b><br>
In normal operation, there is an interrupt event when the number of received bits meets the requirement which defined in TX_BIT_LEN.
<br>
If the number of received bits is less than the requirement and there is no more bus clock input over one transfer time in Slave 3-wire mode, user can set this bit to force the current transfer done and then user can get a unit transfer interrupt event.
<br>
0 = No force the transfer done when the NOSLVSEL bit is set to 1.
<br>
1 = Force the transfer done when the NOSLVSEL bit is set to 1.
<br>
Note: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.
<br>
</div></td></tr><tr><td>
[10]</td><td>SSTA_INTEN</td><td><div style="word-wrap: break-word;"><b>Slave 3-wire Mode Start Interrupt Enable Control (Slave Only)
</b><br>
It is used to enable interrupt when the transfer has started in slave 3-wire mode.
<br>
If there is no transfer done interrupt over the time period which is defined by user after the transfer start, user can set the SLV_ABORT bit to force the transfer done.
<br>
0 = Transaction start interrupt Disabled.
<br>
1 = Transaction start interrupt Enabled.
<br>
Note: It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared to 0.
<br>
</div></td></tr><tr><td>
[11]</td><td>SLV_START_INTSTS</td><td><div style="word-wrap: break-word;"><b>Slave 3-wire Mode Start Interrupt Status (Slave Only)
</b><br>
This bit dedicates if a transaction has started in slave 3-wire mode.
<br>
0 = Slave does not detect any SPI bus clock transfer since the SSTA_INTEN bit was set to 1.
<br>
1 = The transfer has started in slave 3-wire mode.
<br>
Note 1: It will be cleared automatically when a transaction is done or by writing 1 to this bit.
<br>
Note 2: It is a mutual mirror bit of SPI_STATUS[11].
<br>
</div></td></tr><tr><td>
[16]</td><td>SS_INT_OPT</td><td><div style="word-wrap: break-word;"><b>Slave Select Inactive Interrupt Option (Slave Only)
</b><br>
0 = As the slave select signal goes to inactive level, the IF bit will NOT be set to 1.
<br>
1 = As the slave select signal goes to inactive level, the IF bit will be set to 1.
<br>
Note: This setting is only available if the SPI controller is configured as level trigger in slave device.
<br>
</div></td></tr><tr><td>
[31]</td><td>BCn</td><td><div style="word-wrap: break-word;"><b>Clock Configuration Backward Compatible Option
</b><br>
0 = The clock configuration is backward compatible.
<br>
1 = The clock configuration is not backward compatible.
<br>
Note: Refer to the description of SPI_DIVIDER register for details.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l07923">7923</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a94a2d308eeea05b9ed0de03a6f15d80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a2d308eeea05b9ed0de03a6f15d80f">&#9670;&nbsp;</a></span>DIVIDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::DIVIDER</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">DIVIDER
</font><br><p> <font size="2">
Offset: 0x04  SPI Clock Divider Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>DIVIDER</td><td><div style="word-wrap: break-word;"><b>Clock Divider Bits (Master Only)
</b><br>
The value in this field is the frequency divider to determine the SPI peripheral clock frequency fspi, and the SPI master's bus clock frequency on the SPICLK output pin.
<br>
The frequency is obtained according to the following equation:
<br>
If the bit of BCn, SPI_CNTRL2[31], is set to 0.
<br>
else if BCn is set to 1,
<br>
where
<br>
is the SPI peripheral clock source which is defined in the CLKSEL1 register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l07910">7910</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a787691d1bc8968582b5e89b0f7e6e0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787691d1bc8968582b5e89b0f7e6e0f0">&#9670;&nbsp;</a></span>FIFO_CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::FIFO_CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FIFO_CTL
</font><br><p> <font size="2">
Offset: 0x40  SPI FIFO Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RX_CLR</td><td><div style="word-wrap: break-word;"><b>Clear Receive FIFO Buffer
</b><br>
0 = No effect.
<br>
1 = Clear receive FIFO buffer.
<br>
Note: This bit will be cleared to 0 by hardware after software sets it to 1 and the receive FIFO is cleared.
<br>
</div></td></tr><tr><td>
[1]</td><td>TX_CLR</td><td><div style="word-wrap: break-word;"><b>Clear Transmit FIFO Buffer
</b><br>
0 = No effect.
<br>
1 = Clear transmit FIFO buffer.
<br>
Note: This bit will be cleared to 0 by hardware after software sets it to 1 and the transmit FIFO is cleared.
<br>
</div></td></tr><tr><td>
[2]</td><td>RX_INTEN</td><td><div style="word-wrap: break-word;"><b>Receive Threshold Interrupt Enable Control
</b><br>
0 = Receive threshold interrupt Disabled.
<br>
1 = Receive threshold interrupt Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>TX_INTEN</td><td><div style="word-wrap: break-word;"><b>Transmit Threshold Interrupt Enable Control
</b><br>
0 = Transmit threshold interrupt Disabled.
<br>
1 = Transmit threshold interrupt Enabled.
<br>
</div></td></tr><tr><td>
[6]</td><td>RXOV_INTEN</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Overrun Interrupt Enable Control
</b><br>
0 = Receive FIFO overrun interrupt Disabled.
<br>
1 = Receive FIFO overrun interrupt Enabled.
<br>
</div></td></tr><tr><td>
[21]</td><td>TIMEOUT_INTEN</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Time-out Interrupt Enable Control
</b><br>
0 = Time-out interrupt Disabled.
<br>
1 = Time-out interrupt Enabled.
<br>
</div></td></tr><tr><td>
[25:24]</td><td>RX_THRESHOLD</td><td><div style="word-wrap: break-word;"><b>Received FIFO Threshold
</b><br>
If the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting, the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.
<br>
</div></td></tr><tr><td>
[29:28]</td><td>TX_THRESHOLD</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Threshold
</b><br>
If the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l07924">7924</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a4ec4bee1b0ac67e6d48beca95d9a41bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec4bee1b0ac67e6d48beca95d9a41bb">&#9670;&nbsp;</a></span>RX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::RX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">RX
</font><br><p> <font size="2">
Offset: 0x10  SPI Data Receive Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[31:0]</td><td>RX</td><td><div style="word-wrap: break-word;"><b>Data Receive Bits (Read Only)
</b><br>
The Data Receive Registers hold the value of received data of the last executed transfer.
<br>
Valid bits depend on the transmit bit length field in the SPI_CNTRL register.
<br>
For example, if TX_BIT_LEN is set to 0x08, bit RX [7:0] holds the received data.
<br>
The values of the other bits are unknown.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l07915">7915</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a79443ba1b07520f8ec9024696858a190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79443ba1b07520f8ec9024696858a190">&#9670;&nbsp;</a></span>SSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::SSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">SSR
</font><br><p> <font size="2">
Offset: 0x08  SPI Slave Select Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>SSR</td><td><div style="word-wrap: break-word;"><b>Slave Select Control Bit (Master Only)
</b><br>
If AUTOSS bit is 0,
<br>
0 = Set the SPISS line to inactive state.
<br>
1 = Set the proper SPISS line to active state.
<br>
If AUTOSS bit is 1,
<br>
0 = Keep the SPISS line at inactive state.
<br>
1 = Select the SPISS line to be automatically driven to active state for the duration of transmission/reception, and will be driven to inactive state for the rest of the time.
<br>
The active state of SPISS is specified in SS_LVL bit.
<br>
</div></td></tr><tr><td>
[2]</td><td>SS_LVL</td><td><div style="word-wrap: break-word;"><b>Slave Select Active Level (Slave Only)
</b><br>
It defines the active status of slave select signal (SPISS).
<br>
If SS_LTRIG bit is 1:
<br>
0 = The slave select signal SPISS is active at Low-level.
<br>
1 = The slave select signal SPISS is active at High-level.
<br>
If SS_LTRIG bit is 0:
<br>
0 = The slave select signal SPISS is active at Falling-edge.
<br>
1 = The slave select signal SPISS is active at Rising-edge.
<br>
</div></td></tr><tr><td>
[3]</td><td>AUTOSS</td><td><div style="word-wrap: break-word;"><b>Automatic Slave Selection Function Enable Bit (Master Only)
</b><br>
0 = SPISS pin signal will be asserted/de-asserted by setting /clearing SSR bit.
<br>
1 = SPISS pin signal will be generated automatically, which means that slave select signal will be asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and will be de-asserted after each transmit/receive is finished.
<br>
</div></td></tr><tr><td>
[4]</td><td>SS_LTRIG</td><td><div style="word-wrap: break-word;"><b>Slave Select Level Trigger Enable Bit (Slave Only)
</b><br>
0 = The input slave select signal is edge-trigger.
<br>
1 = The input slave select signal is level-trigger.
<br>
</div></td></tr><tr><td>
[5]</td><td>LTRIG_FLAG</td><td><div style="word-wrap: break-word;"><b>Level Trigger Flag (Read Only, Slave Only)
</b><br>
When the SS_LTRIG bit is set in Slave mode, this bit can be read to indicate the received bit number is met the requirement or not.
<br>
0 = The transaction number or the transferred bit length of one transaction does not meet the specified requirements.
<br>
1 = The transaction number and the transferred bit length met the specified requirements which defined in TX_BIT_LEN.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l07911">7911</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="a463a7dc0398240e38e1c356316e79a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463a7dc0398240e38e1c356316e79a4d">&#9670;&nbsp;</a></span>STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">STATUS
</font><br><p> <font size="2">
Offset: 0x44  SPI Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RX_INTSTS</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Threshold Interrupt Status (Read Only)
</b><br>
0 = The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RX_THRESHOLD.
<br>
1 = The valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD.
<br>
Note: If RX_INTEN = 1 and RX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
<br>
</div></td></tr><tr><td>
[2]</td><td>RX_OVERRUN</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Overrun Status
</b><br>
When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
<br>
0 = No overrun in receive FIFO.
<br>
1 = Overrun in receive FIFO.
<br>
Note: This bit will be cleared by writing 1 to itself.
<br>
</div></td></tr><tr><td>
[4]</td><td>TX_INTSTS</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Threshold Interrupt Status (Read Only)
</b><br>
0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD.
<br>
1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD.
<br>
Note: If TX_INTEN = 1 and TX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
<br>
</div></td></tr><tr><td>
[11]</td><td>SLV_START_INTSTS</td><td><div style="word-wrap: break-word;"><b>Slave Start Interrupt Status (Slave Only)
</b><br>
It is used to dedicate that the transfer has started in slave 3-wire mode.
<br>
0 = Slave does not detect any SPI bus clock transfer since the SSTA_INTEN bit was set to 1.
<br>
1 = The transfer has started in slave 3-wire mode.
<br>
Note 1: It will be cleared as transfer done or by writing one to this bit.
<br>
Note 2: It's a mutual mirror bit of SPI_CNTRL2[11].
<br>
</div></td></tr><tr><td>
[15:12]</td><td>RX_FIFO_COUNT</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Data Count (Read Only)
</b><br>
Indicates the valid data count of receive FIFO buffer.
<br>
</div></td></tr><tr><td>
[16]</td><td>IF</td><td><div style="word-wrap: break-word;"><b>SPI Unit-transfer Interrupt Flag
</b><br>
0 = The transfer does not finish yet.
<br>
1 = The SPI controller has finished one unit transfer.
<br>
Note 1: This bit will be cleared by writing 1 to itself.
<br>
Note 2: It's a mutual mirror bit of SPI_CNTRL[16].
<br>
</div></td></tr><tr><td>
[20]</td><td>TIMEOUT</td><td><div style="word-wrap: break-word;"><b>Time-out Interrupt Flag
</b><br>
0 = No receive FIFO time-out event.
<br>
1 = The receive FIFO buffer is not empty and it does not be read over 64 SPI clock periods in Master mode or over 576 SPI peripheral clock periods in Slave mode.
<br>
When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
<br>
Note: This bit will be cleared by writing 1 to itself.
<br>
</div></td></tr><tr><td>
[24]</td><td>RX_EMPTY</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Buffer Empty Indicator (Read Only)
</b><br>
0 = The receive FIFO buffer is not empty.
<br>
1 = The receive FIFO buffer is empty.
<br>
Note: It's a mutual mirror bit of SPI_CNTRL[24].
<br>
</div></td></tr><tr><td>
[25]</td><td>RX_FULL</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Buffer Full Indicator (Read Only)
</b><br>
0 = The receive FIFO buffer is not full.
<br>
1 = The receive FIFO buffer is full.
<br>
Note: It's a mutual mirror bit of SPI_CNTRL[25].
<br>
</div></td></tr><tr><td>
[26]</td><td>TX_EMPTY</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Buffer Empty Indicator (Read Only)
</b><br>
0 = The transmit FIFO buffer is not empty.
<br>
1 = The transmit FIFO buffer is empty.
<br>
Note: It's a mutual mirror bit of SPI_CNTRL[26].
<br>
</div></td></tr><tr><td>
[27]</td><td>TX_FULL</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Buffer Full Indicator (Read Only)
</b><br>
0 = The transmit FIFO buffer is not full.
<br>
1 = The transmit FIFO buffer is full.
<br>
Note: It's a mutual mirror bit of SPI_CNTRL[27].
<br>
</div></td></tr><tr><td>
[31:28]</td><td>TX_FIFO_COUNT</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Data Count (Read Only)
</b><br>
Indicates the valid data count of transmit FIFO buffer.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l07925">7925</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<a id="aacfc54f0cd2fc536fb4e7eb0b8f9f18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfc54f0cd2fc536fb4e7eb0b8f9f18c">&#9670;&nbsp;</a></span>TX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::TX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TX
</font><br><p> <font size="2">
Offset: 0x20  SPI Data Transmit Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[31:0]</td><td>TX</td><td><div style="word-wrap: break-word;"><b>Data Transmit Bits (Write Only)
</b><br>
The Data Transmit Registers hold the data to be transmitted in the next transfer.
<br>
Valid bits depend on the transmit bit length field in the CNTRL register.
<br>
For example, if TX_BIT_LEN is set to 0x08, the bit TX [7:0] will be transmitted in next transfer.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_mini51_series_8h_source.html#l07919">7919</a> of file <a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Device/Nuvoton/Mini51Series/Include/<a class="el" href="_mini51_series_8h_source.html">Mini51Series.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 5 2020 14:31:45 for Mini51 BSP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
